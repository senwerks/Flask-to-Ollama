<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ollama Interface</title>

    <link rel="stylesheet" href="{{ url_for('static', filename='css/nano.min.css') }}" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],  
                displayMath: [['$$', '$$'], ['\\[', '\\]']]  
            },
            svg: { scale: 1.2 }
        };
    </script>
    <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <div class="container">
        <section>
            <h1>Ollama Interface</h1>
            Ollama server is currently: <mark>{{ ollama_status }}</mark>
        </section>
        <section>
            <h2>Submit Prompt</h2>
            <form id="prompt-form">
                <label for="model">Model</label>
                <select id="model" name="model">
                    {% for model in models %}
                        <option value="{{ model }}">{{ model }}</option>
                    {% endfor %}
                </select>
                <br>
                <label for="prompt">Prompt</label>
                <textarea id="prompt" name="prompt"></textarea>
                <br>
                <div id="status"></div>
                <br>
                <button type="submit">Submit</button>
            </form>
            <div id="response"></div>
        </section>

        <section>
            <small></small>
        </section>
    </div>
    
    <script>
        // Custom Renderer to Preserve MathJax Syntax
        const renderer = new marked.Renderer();

        // Override code block rendering to prevent escaping math blocks
        renderer.paragraph = function(text) {
            return text.replace(/\\\[/g, '\\[') // Keep block math \[
                        .replace(/\\\]/g, '\\]') // Keep block math \]
                        .replace(/\\\(/g, '\\(') // Keep inline math \(
                        .replace(/\\\)/g, '\\)'); // Keep inline math \)
        };

        // Apply custom renderer to marked
        marked.use({ renderer });

        document.getElementById("prompt-form").addEventListener("submit", async function(event) {
            event.preventDefault(); // Prevent default form submission
    
            const model = document.getElementById("model").value;
            const prompt = document.getElementById("prompt").value;
            const statusElement = document.getElementById("status");
            const responseElement = document.getElementById("response");
    
            // Show status while waiting for response
            statusElement.innerHTML = "<div class=\"warning\" role=\"alert\">Waiting for response...</div>";
            responseElement.innerHTML = ""; // Clear previous response
    
            try {
                const response = await fetch("/api", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                    },
                    body: new URLSearchParams({ model, prompt })
                });
    
                const data = await response.json();
                
                // Replace <think> with <blockquote> tags
                const formattedResponse = data.response
                    .replace(/<think>/g, '<h2>Thinking:</h2><blockquote>')
                    .replace(/<\/think>/g, '</blockquote><h2>Conclusion:</h2>');

                // Convert Markdown to HTML using 'marked' with the custom renderer
                const htmlResponse = marked.parse(formattedResponse);

                // Insert formatted response into the HTML
                responseElement.innerHTML = `
                    <p><strong>Response:</strong> ${htmlResponse}</p>
                `;

                // Re-render MathJax after updating innerHTML
                if (window.MathJax) {
                    window.MathJax.typesetPromise();
                }

                // Update status to "Done!"
                statusElement.innerHTML = "<div class=\"success\" role=\"alert\">Response received.</div>";
            } catch (error) {
                statusElement.innerHTML = "<div class=\"danger\" role=\"alert\">Error fetching response!</div>";
            }
        });
    </script>
    
</body>
</html>
